const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

const rootDir = path.resolve(__dirname, '..');
const packageJsonPath = path.join(rootDir, 'package.json');
const srcVersionPath = path.join(rootDir, 'src', 'version.js');
const publicVersionPath = path.join(rootDir, 'public', 'version.json');
const swPath = path.join(rootDir, 'public', 'sw.js');

const command = process.argv[2];
const arg = process.argv[3];

const usage = () => {
  console.error('Usage: node scripts/versioning.js <check|generate|bump> [patch|minor|major]');
};

const readPackage = () => JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

const run = (cmd, args) => {
  const res = spawnSync(cmd, args, {
    cwd: rootDir,
    stdio: 'inherit',
  });
  if (res.status !== 0) {
    process.exit(res.status || 1);
  }
};

const checkVersion = () => {
  const packageVersion = readPackage().version;
  const srcVersionContents = fs.readFileSync(srcVersionPath, 'utf8');
  const srcMatch = srcVersionContents.match(/APP_VERSION\s*=\s*'([^']+)'/);
  const srcVersion = srcMatch ? srcMatch[1] : null;
  const publicVersion = JSON.parse(fs.readFileSync(publicVersionPath, 'utf8')).version;

  const problems = [];
  if (!srcVersion) problems.push('src/version.js does not contain APP_VERSION');
  if (packageVersion !== srcVersion) {
    problems.push(`package.json (${packageVersion}) != src/version.js (${srcVersion})`);
  }
  if (packageVersion !== publicVersion) {
    problems.push(`package.json (${packageVersion}) != public/version.json (${publicVersion})`);
  }

  if (problems.length > 0) {
    console.error('Version mismatch:');
    problems.forEach((problem) => console.error(`- ${problem}`));
    process.exit(1);
  }

  console.log(`Version check OK (${packageVersion})`);
};

const generateVersion = () => {
  const version = readPackage().version;
  const buildTime = new Date().toISOString();

  const versionJs = `// Generated by scripts/versioning.js\nexport const APP_VERSION = '${version}';\nexport const BUILD_TIME = '${buildTime}';\n`;
  const versionJson = JSON.stringify({ version, buildTime }, null, 2);

  fs.writeFileSync(srcVersionPath, versionJs, 'utf8');
  fs.writeFileSync(publicVersionPath, `${versionJson}\n`, 'utf8');

  const swContent = fs.readFileSync(swPath, 'utf8');
  let updatedSwContent = swContent.replace(/__APP_VERSION__/g, version);
  updatedSwContent = updatedSwContent.replace(
    /(const BUILD_VERSION = ')([^']+)(')/,
    `$1${version}$3`,
  );
  fs.writeFileSync(swPath, updatedSwContent, 'utf8');

  console.log(`Version files written for ${version}`);
};

const bumpVersion = (bumpType) => {
  const validTypes = new Set(['patch', 'minor', 'major']);
  if (!validTypes.has(bumpType)) {
    console.error('Usage: node scripts/versioning.js bump <patch|minor|major>');
    process.exit(1);
  }

  const packageJson = readPackage();
  const [major, minor, patch] = packageJson.version.split('.').map(Number);
  if ([major, minor, patch].some((n) => Number.isNaN(n))) {
    console.error(`Invalid version in package.json: ${packageJson.version}`);
    process.exit(1);
  }

  let nextVersion = '';
  if (bumpType === 'patch') nextVersion = `${major}.${minor}.${patch + 1}`;
  if (bumpType === 'minor') nextVersion = `${major}.${minor + 1}.0`;
  if (bumpType === 'major') nextVersion = `${major + 1}.0.0`;

  console.log(`Bumping version from ${packageJson.version} to ${nextVersion}`);
  packageJson.version = nextVersion;
  fs.writeFileSync(packageJsonPath, `${JSON.stringify(packageJson, null, 2)}\n`, 'utf8');

  console.log('Updating package-lock.json...');
  run('npm', [
    'install',
    '--package-lock-only',
    '--ignore-scripts',
    '--no-audit',
    '--no-fund',
  ]);

  console.log(`Version bump to ${nextVersion} completed successfully.`);
};

if (command === 'check') {
  checkVersion();
} else if (command === 'generate') {
  generateVersion();
} else if (command === 'bump') {
  bumpVersion(arg);
} else {
  usage();
  process.exit(1);
}
