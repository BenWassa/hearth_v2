const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

const rootDir = path.resolve(__dirname, '..');
const packageJsonPath = path.join(rootDir, 'package.json');
const srcVersionPath = path.join(rootDir, 'src', 'version.js');
const publicVersionPath = path.join(rootDir, 'public', 'version.json');
const swPath = path.join(rootDir, 'public', 'sw.js');

const command = process.argv[2];
const arg = process.argv[3];

const usage = () => {
  console.error('Usage: node scripts/versioning.js <check|generate|bump> [patch|minor|major]');
};

const readPackage = () => JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

const resolveGitSha = () => {
  const candidates = [
    process.env.GIT_COMMIT_SHA,
    process.env.COMMIT_SHA,
    process.env.SOURCE_COMMIT,
    process.env.GITHUB_SHA,
  ];

  for (const candidate of candidates) {
    if (typeof candidate === 'string' && candidate.trim()) {
      return candidate.trim().slice(0, 7);
    }
  }

  const gitResult = spawnSync('git', ['rev-parse', '--short', 'HEAD'], {
    cwd: rootDir,
    encoding: 'utf8',
  });
  if (gitResult.status === 0 && gitResult.stdout) {
    return gitResult.stdout.trim();
  }

  return 'nogit';
};

const toBuildStamp = (isoTime) => isoTime.replace(/[-:.TZ]/g, '').slice(0, 14);

const createBuildId = (version, buildTime) => {
  const gitSha = resolveGitSha();
  return `${version}-${toBuildStamp(buildTime)}-${gitSha}`;
};

const run = (cmd, args) => {
  const res = spawnSync(cmd, args, {
    cwd: rootDir,
    stdio: 'inherit',
  });
  if (res.status !== 0) {
    process.exit(res.status || 1);
  }
};

const checkVersion = () => {
  const packageVersion = readPackage().version;
  const srcVersionContents = fs.readFileSync(srcVersionPath, 'utf8');
  const srcMatch = srcVersionContents.match(/APP_VERSION\s*=\s*'([^']+)'/);
  const srcBuildIdMatch = srcVersionContents.match(/BUILD_ID\s*=\s*'([^']+)'/);
  const srcVersion = srcMatch ? srcMatch[1] : null;
  const srcBuildId = srcBuildIdMatch ? srcBuildIdMatch[1] : null;
  const publicVersionFile = JSON.parse(fs.readFileSync(publicVersionPath, 'utf8'));
  const publicVersion = publicVersionFile.version;
  const publicBuildId = publicVersionFile.buildId;
  const swContent = fs.readFileSync(swPath, 'utf8');
  const swVersionMatch = swContent.match(/BUILD_VERSION\s*=\s*'([^']+)'/);
  const swBuildIdMatch = swContent.match(/BUILD_ID\s*=\s*'([^']+)'/);
  const swVersion = swVersionMatch ? swVersionMatch[1] : null;
  const swBuildId = swBuildIdMatch ? swBuildIdMatch[1] : null;

  const problems = [];
  if (!srcVersion) problems.push('src/version.js does not contain APP_VERSION');
  if (!srcBuildId) problems.push('src/version.js does not contain BUILD_ID');
  if (packageVersion !== srcVersion) {
    problems.push(`package.json (${packageVersion}) != src/version.js (${srcVersion})`);
  }
  if (packageVersion !== publicVersion) {
    problems.push(`package.json (${packageVersion}) != public/version.json (${publicVersion})`);
  }
  if (packageVersion !== swVersion) {
    problems.push(`package.json (${packageVersion}) != public/sw.js (${swVersion})`);
  }
  if (!publicBuildId) problems.push('public/version.json does not contain buildId');
  if (!swBuildId) problems.push('public/sw.js does not contain BUILD_ID');
  if (srcBuildId && publicBuildId && srcBuildId !== publicBuildId) {
    problems.push(`src/version.js build ID (${srcBuildId}) != public/version.json build ID (${publicBuildId})`);
  }
  if (srcBuildId && swBuildId && srcBuildId !== swBuildId) {
    problems.push(`src/version.js build ID (${srcBuildId}) != public/sw.js build ID (${swBuildId})`);
  }

  if (problems.length > 0) {
    console.error('Version mismatch:');
    problems.forEach((problem) => console.error(`- ${problem}`));
    process.exit(1);
  }

  console.log(`Version check OK (${packageVersion})`);
};

const generateVersion = () => {
  const version = readPackage().version;
  const buildTime = new Date().toISOString();
  const buildId = createBuildId(version, buildTime);

  const versionJs = `// Generated by scripts/versioning.js\nexport const APP_VERSION = '${version}';\nexport const BUILD_TIME = '${buildTime}';\nexport const BUILD_ID = '${buildId}';\n`;
  const versionJson = JSON.stringify({ version, buildTime, buildId }, null, 2);

  fs.writeFileSync(srcVersionPath, versionJs, 'utf8');
  fs.writeFileSync(publicVersionPath, `${versionJson}\n`, 'utf8');

  const swContent = fs.readFileSync(swPath, 'utf8');
  let updatedSwContent = swContent.replace(/__APP_VERSION__/g, version);
  updatedSwContent = updatedSwContent.replace(/__BUILD_ID__/g, buildId);
  updatedSwContent = updatedSwContent.replace(
    /(const BUILD_VERSION = ')([^']+)(')/,
    `$1${version}$3`,
  );
  updatedSwContent = updatedSwContent.replace(
    /(const BUILD_ID = ')([^']+)(')/,
    `$1${buildId}$3`,
  );
  fs.writeFileSync(swPath, updatedSwContent, 'utf8');

  console.log(`Version files written for ${version} (${buildId})`);
};

const bumpVersion = (bumpType) => {
  const validTypes = new Set(['patch', 'minor', 'major']);
  if (!validTypes.has(bumpType)) {
    console.error('Usage: node scripts/versioning.js bump <patch|minor|major>');
    process.exit(1);
  }

  const packageJson = readPackage();
  const [major, minor, patch] = packageJson.version.split('.').map(Number);
  if ([major, minor, patch].some((n) => Number.isNaN(n))) {
    console.error(`Invalid version in package.json: ${packageJson.version}`);
    process.exit(1);
  }

  let nextVersion = '';
  if (bumpType === 'patch') nextVersion = `${major}.${minor}.${patch + 1}`;
  if (bumpType === 'minor') nextVersion = `${major}.${minor + 1}.0`;
  if (bumpType === 'major') nextVersion = `${major + 1}.0.0`;

  console.log(`Bumping version from ${packageJson.version} to ${nextVersion}`);
  packageJson.version = nextVersion;
  fs.writeFileSync(packageJsonPath, `${JSON.stringify(packageJson, null, 2)}\n`, 'utf8');

  console.log('Updating package-lock.json...');
  run('npm', [
    'install',
    '--package-lock-only',
    '--ignore-scripts',
    '--no-audit',
    '--no-fund',
  ]);

  console.log(`Version bump to ${nextVersion} completed successfully.`);
};

if (command === 'check') {
  checkVersion();
} else if (command === 'generate') {
  generateVersion();
} else if (command === 'bump') {
  bumpVersion(arg);
} else {
  usage();
  process.exit(1);
}
